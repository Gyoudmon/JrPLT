#lang scribble/book

@(require "../../literacy.rkt")

@;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@handbook-story{自然语言与程序语言}

毋庸置疑，当提到语文和英语时，我们知道它们都是语言类课程。
具体来说，语文代表母语，英语代表外语，
学习它们可以帮助我们更好地表达自己、与他人沟通；
同时母语承载着本民族的文化、外语承载着各自民族的文化。
于是，像汉语、英语这样，
随着人们交流的需要而自然而然形成和发展的语言
称为@handbook-defterm[#:origin "Natural Language"]{自然语言}。

@tech{自然语言}强调的是@emph{“人与人”}之间的交流，
以及@emph{“自然而然”}的形成。
言下之意，非自然形成的语言必然不是自然语言；
非人类生物如果有交流也不能说它们的语言是自然语言。
好吧，这段话深得废话文学的精髓(并不是)。

@handbook-defterm[#:origin "Progamming Language"]{程序语言}指
的是一系列驱动机器做事的咒语。
喏，这里并不强调“与机器的(双向)交流”，
而是强调一种“使役关系”：我叫你做什么你做就完了，别跟我讨价还价！
因此，用@tech{程序语言}“说”的话通常也称
作@handbook-defterm[#:origin "Command"]{命令}或@handbook-defterm[#:origin "Instruction"]{指令}。
即使某些软件的措辞时常让你感受到一种宾至如归的温馨感，
那也是软件的作者要求这个软件“必须让用户觉得他们是大爷”，
属实是演技派社牛。

那么，@tech{程序语言}中的“语言”跟@tech{自然语言}中的“语言”是同一个意思吗？
当然是，要不然就不会叫语言了。
实际上，@tech{程序语言}产生之初的确不叫语言。
从1840年代算起，一百多年间，它们最主要的身份是数学记号(Notation),
就如同@${a + b}，@${(x, y)}之类的符号一样。
直到1950年代，“语言”才正式成为早起有影响力的@tech{程序语言}名字的一部分，
比如这个叫做@emph{算法语言}的ALGOL，即是
@litchar{ALGO}rithmic @litchar{L}anguage 的缩写。

而从“记号”到“语言”，这个过程并非改个名字这么简单，
尤其困难的是让社会其他人接纳这个称作“语言”的东西确实名副其实。
这其实也是好多学术前辈努力争取来的，
其中包括 Ada LoveLace，英国女性数学家，
也是被最多人认可的“历史上第一个写程序的人”。

@handbook-scenario{语言与语言的异同}

先正面回答，这两个“语言”为什么是同一个意思？

在2014年，来自神经科学的证据首次证实了，
会写代码的人在阅读代码时激活的脑区与
人们理解@tech{自然语言}时所激活的脑区完全一致。
此结论后又于2017年被再次证实，
阅读程序代更像阅读散文(Prose)。

@margin-note*{注意这里的“物体命名”，
 命名是件相当考验语言功底的事。
 在编程过程中，我们需要不断地给各种概念、事物命名，
 因而学编程至少能提高英语遣词造句的能力。
}也就是说，对于工作记忆、单词提取、物体命名、规划与决策等等
一系列与语言有关的活动，我们大脑的语言中枢并不区分语言的类型，
对@tech{自然语言}、@tech{程序语言}一视同仁。
而且，更有趣的是，此结论同样适用于其他类型的语言。
比如，手语、音乐等等。

另一方面，现代教育已经无需再讨论是单语教育还是双语教育了，
因为小学低年级就已经开始学外语。这既是事实，
也因为双语教育确实好处多多，比如：记忆力、批判性思维、
专注力、多任务处理能力、问题求解能力、听力、
创造力及认知弹性等均有提升。
@focus{对了，这些认知优势的提升与年龄无关，
 “只有孩子才能学外语”这种广为流传的谬论被新的研究推翻了。}

于是，问题就转化为了选择什么类型的双语教育：
@emph{母语+外语}还是@emph{母语+程序语言}？
美国法学界近年来不断讨论相关话题，
是否允许学生提交@tech{程序语言}替代外语作为毕业凭证？
大多数州的考虑还是，@tech{程序语言}不适合正常与人交流，不行；
仅有 Texas 允许学生提交@tech{程序语言}，如果实在学不会外语的话。
总之，这还是个开放性问题，暂且不表。

@handbook-action{差异}

社会、教育尺度太大，有待进一步研究。
不过仅从我们个人学习的角度来看，还是有必要继续讨论的。
这两种语言就真的没有差异吗？

@handbook-scenario{先有程序语言还是先有计算机器？}

“@tech{程序语言}”和“计算机器”的关系没有“先有鸡还是先有蛋”的困惑。
有定论，@tech{程序语言}比真正意义上的计算机早出现一个多世纪。
最早的还没有被称为语言的@tech{程序语言}发明者是英国数学家和计算机先驱
Charles Babbage，他设想了一个称作“分析机”的通用机械式计算机，
用数学家更熟悉的符号@handbook-footnote{
 这个数学符号其实就是现代数学家称之为“形式语言”的东西。
 形式语言是更一般的语言类别，它既包括数学记号，
 也包括@tech{程序语言}。Babbage 的符号系统很像现在的汇编语言。
 }来编程。
不过，这个分析机直到现在都没有被真的制造出来。

Ada Lovelace 也是 Babbage 的分析社团的核心贡献者，
他们尝试让社会明白的事不仅仅关乎“记号和语言”，
而是更重要的认知理念：@idea{语言的书写符号并不等价，
 有些符号比另一些符号更便于人脑来理解}。
就他们当时的经历，他们让现在的微积分教科书统一采用了
Leibniz 的记号，而不是 Newton 的。
不过，这里我们换一个更本土化的例子来解释：对于加法运算，
“@${101 + 101 = 202}”和“@emph{壹佰〇壹加壹佰〇壹等于贰佰〇贰}”
这两种写法，你更喜欢哪一个？
这个问题也能帮你思考，为什么存在如此多的@tech{程序语言}？
而它们中的很多，似乎又仅仅只是语法不同。

从以上故事里，我们还能初步得到一个关于数学和计算机科学的模糊印象：
数学存在于纸上(和大神的脑子里)，不接地气；
计算机科学则是可以通过特殊机器来执行的数学。
像中考、高考这样的重要考试，答题卡是要先被阅卷机器扫描的。
到这里你是不是会想，等学会了编程就可以在答题卡上写一段代码，
让阅卷机器直接判满分？
嘿嘿嘿嘿，你解锁了一个很关键的思想。
不过现在先不着急，在本书后续部分我们会多次审视这个设想。

总之，我们人类是语言性生物，
@tech{程序语言}则是千百年来人类创造的最神奇的东西，没有之一。
我们现在正处在信息时代中，
而这个时代的一切数字化生存都建立在@tech{程序语言}编织的软件之上。
在本书中，“语言”一词可以是以下任意一种或多种隐喻：
你我交流的媒介；
需要习得的知识、掌握的方法、做事的工具；
甚至是一种魔法。

@handbook-reference[]
