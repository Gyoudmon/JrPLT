#lang scribble/manual

@require{literacy.rkt}
@require{diagram/architecture.rkt}

@(require geofun/vector)

@;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@handbook-root-story{系统概要设计}
@handbook-word-count[]

@handbook-scenario{引擎内核架构设计}
@handbook-word-count[]

软件系统往往会按照明显的层次结构构建，
并且约定上层模块建立在下层模块提供的功能之上，
但是不能反过来形成“循环依赖”。
这个设计原则对于诸如游戏引擎这样的大型软件系统尤其重要。

@tamer-figure![
 'arch.dia
 @list{引擎内核架构简图}]{
 @(geo-scale architecture.dia 0.5)
}

@fig-ref{arch.dia}展示的是本引擎内核的架构简图，
它也按照层次结构组织，
但跟现代游戏引擎的层次结构有所不同。
除去最底层的操作系统和最顶层的应用，
我们按照自底向上的顺序简要介绍一下各层职能，
重要、有趣的部分留到后文合适的地方再详细说明。

@handbook-itemlist[
 #:style 'compact

 @item{C++ 运行时和 SDL2 共同构成了本引擎的平台无关层。
  或者反过来说，
  C++ 标准库和SDL2 帮我们隐藏了几乎所有的平台无关细节。}
 
 @item{数据类型包装和底层渲染共同构成了本引擎的基础设施层。
  该层是本项目编写代码的起点，
  当前版本就是补充了 C++ 标准库该有而没有的功能，
  后续版本可向 GPU 或更强大的图形系统借力。
 }
 
 @item{物理系统和虚拟化共同构成了本引擎的核心层。
  该层定义了游戏引擎中常见的数学对象、物理对象和支持系统。
  属于用户无法直接感知但又不可或缺的部分。}

 @item{功能层则连接了引擎内核和应用层。简而言之，
  该层以图形用户接口的名义组织了下层的各模块让用户能够直接感知到引擎正在运行，
  同时定义了应用软件应该遵守的逻辑模型和限制。}
 ]

@handbook-scenario{项目制课程总体设计}
@handbook-word-count[]

从前文需求分析部分可知，
项目制课程由一系列主题课构成，
每个项目制课程拥有自己的独立启动程序来管理所有主题课。
它作为本引擎的代表应用类型之一，
非常适合用来引出对“可视元素模型”的设计。

@handbook-scenario{网络通信协议}
@handbook-word-count[]

@;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@handbook-reference[]
