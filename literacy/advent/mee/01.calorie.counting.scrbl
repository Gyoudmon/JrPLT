#lang scribble/lp2

@(require "../literacy.rkt")

@;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@(define Puzzle:1 "找到携带食物能提供最多卡路里的精灵，并计算他所携带的卡路里总和")

@;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@aoc-task[2022 1]{计点卡路里}

@aoc-desc[#:keywords ["文学式编程" "函数式编程" "类型签名" "REPL" "列表" "sexp" "递归函数" "高阶函数"]
          #:edition [三 "2024-06-12"]]

远征第一天，故事主线任务不会太复杂，
因此我们有时间来习惯本书的写作风格。

阅读本章时，
读者应当重点关注的是@:val{如何将解谜思路翻译成代码}，
而不是纠结于晦涩的概念和古怪的语法细节，
那些可以留到后续任务中慢慢磨。

@handbook-scenario{文学式编程}

本章的关键词不多，但都很令人费解。
比如，那个@tech{文学式编程}乍一听就很不合理，
说编程跟数学关系密切可以理解，
但跟文学的关系在哪里呢？
这个关系就是@:term{写作}，
人与人的交流依托自然语言，
人与计算机交流依托的是程序语言。
写作的本质是用文字表达作者的思想或意图，
除了词汇量和熟练度上的差异，写作本身应该与语言无关，
但要考虑读者的接受程度。
优秀的作者还会考虑@focus{语言自身的思维和惯例}。

@handbook-deftech[#:origin "Literate Programming"]{文学式编程}讲究以人为本，
用作者自己的写作思路来写程序，同样阅读程序的人也能更容易理解程序。
这样的程序源码分为散文和代码两部分，
后者给编译程序看，它们会自动将散落在文章各处的代码碎片组装成正确的程序；
前者（和后者共同）给人类读者看。
比如你现在正在阅读的本书就是@tech{文学式编程}的例子。
此外，在 Racket 自身优势的加持下，
文中示例程序的运行结果也是最终程序的直接执行结果（而非额外运行程序之后再把结果复制粘贴过来）。

接下来我们通过完成第一天的主线任务来具体感受一下。

散文中的代码碎片有一个起点，一般就是任务章节中出现的第一个碎片，它看起来是这个样子的：

@handbook-chunk[<calorie:*>
                (module advent typed/racket
                  <主线任务：求解谜题1>
                  <主线任务：求解谜题2>)]

其中用尖括号（@:delim{< >}）括起来的部分就是散落在本章各处的代码碎片的名字，
其本质跟变量名没有什么不一样，比如本任务的起点碎片名为@racket[<calorie:*>]。
起点碎片一般用来确定任务代码的总体框架，
本例定义了一个名为 @:mod{advent} 的模块，
并指定该模块的书写语言为 @:mod{typed/racket}@handbook-footnote{Racket
 是@:term{语言导向}的语言，你还可以换成 @:mod{python}、@:mod{datalog} 等多种其他语言。}；
紧接着的两个碎片名分别指向解决本任务中的两个谜题的代码碎片。

代码碎片可以出现在任何地方，但是起点碎片必须是章节的第一个碎片，
并且只有实际用到的碎片才会出现在最终程序里。
那些没被使用的碎片的价值是继续留在本书里给读者看，
它们或提供了额外信息，或提供了另一种思路。

原始故事作为我们学习编程的情景，以嵌套形式插入文中，以避免跟正文内容互相干扰：

@story*[
 @story{丛林杂草丛生，没法使用交通工具，也没法空降，因此精灵们传统上只能徒步远征。
  当小船快靠岸时，精灵们开始清点物资，食物是重点清点对象之一。
  具体来说，也就是每只精灵携带食物的卡路里含量。}
  
 @story{精灵们轮流把自己携带的各种肉类、点心、口粮等食物的卡路里数写在纸上，
  一行一项，不同精灵之间用空行隔开。}
 
 @story{当有精灵饿了或馋了时，他们需要知道问谁去要零食，即需要知道谁带的卡路里最多。
  请帮助精灵们@question{@|Puzzle:1|}。}]
 
情景部分会用特殊颜色说清楚我们需要解决的问题是什么，
比如第一个问题是@question{@|Puzzle:1|}。
对该谜题的求解就对应着之前给出的碎片@racket[<主线任务：求解谜题1>]。

故事中的例子会从情景部分抽出来放在正文里，作为我们思考的素材。
比如，精灵们写出了如下的一份卡路里清单(清单内容保存在文件中，
后缀名是 @litchar{.aex}，显示在本文中的最左侧一列是行号)：

@(tamer-filebox (aoc-tamer-path "mee/01_cc.aex"))

@linebreak[]
从这份清单可以看到，共有五只精灵，他们所携带食物的卡路里信息如下：

@itemlist[
 #:style 'compact
               
 @item{第一只精灵带了三种食物，卡路里含量分别为 @racket[1000], @racket[2000] 和 @racket[3000]，总计 @racket[6000] 卡。}  
 @item{第二只精灵只带了一种食物，卡路里含量为 @racket[4000] 卡。}
 @item{第三只精灵带了两种食物，卡路里含量分别为 @racket[5000] 和 @racket[6000]，总计 @racket[11000] 卡。}
 @item{第四只精灵带了三种食物，卡路里含量分别为 @racket[7000], @racket[8000] 和 @racket[9000]，总计 @racket[24000] 卡。}
 @item{第五只精灵也只带了一种食物，含 @racket[10000] 卡。}]

于是，经过简单比较，我们可以得到第一个谜题的答案：
第四只精灵携带的食物卡路里含量最高，达到了 @racket[24000] 大卡。

我们暂时先不考虑用什么思路来求解，就先设想一下，
如果不写程序，用纸和笔你会怎么解决这个问题？
要具体到你的眼睛是如何“阅读”卡路里清单的。

阅读清单的方式很多，其中比较自然的一种是：
@:desc[#:tt? #true]{读取清单第一行，如果读到的是数字，说明这行里有卡路里含量信息，
 应当更新当前精灵携带的卡路里信息；
 否则，根据实际情况更新最大卡路里信息，并重置精灵卡路里。
 接着读取下一行，重复上述过程，直到没有更多内容为止}，
此时的最大卡路里即为谜题的答案。
不难看出，阅读清单的过程有着明显的循环特征，
不妨称作@:name{读取-判断-更新循环}，
缩写为 @:sym{rpul}（read-predicate-update loop）。

既然程序语言也被称为语言，那想必也是可以跟其他语言相互翻译的。
从写作的角度来讲，编程就是@idea{把你想做的任务翻译成计算机能理解的语言}。
绝大多数程序语言的语法都比较死板，有很多固定格式要遵守。
咋一看，这是“不说人话”，其实是对简洁和精准的追求。
@margin-note*{除非你就是要造一个没法跟你愉快玩耍的机器人。}
计算机执行任务不应该产生歧义，
一个总是误解你的程序没有存在价值。

照此思路，@:term{读取-判断-更新循环}翻译之后可以是这样的：

@handbook-chunk[<读取-判断-更新循环>
                (let rpul (<变量初始化>)
                  (define line : (U String EOF) <读取一行>)
                  (if <判断是否有内容>
                      (let ([cal : (Option Number) <尝试提取卡路里信息>])
                        (if <判断是否是正整数>
                            <更新精灵卡路里，递推下一轮>
                            <更新最大卡路里，递推下一轮>))
                      <确定最大值>))]

除了一些“固定”格式，它详细列出了我们需要逐句翻译的地方。
不过，这毕竟是一个循环任务，在翻译的时候需要考虑清楚循环的开始和结束；
而且，人脑和计算机都有各自的习惯，
在大多数语言里，你需要@idea{教会计算机所有你自己脑补的细节}，
因此无法完全做到逐句翻译。

接下来，我们只需把那些需要翻译的部分按字面意思一个个翻译成代码即可。
首先是@:desc{变量初始化}。
本题比较简单，直接考虑问题本身，而无需准备辅助变量:

@handbook-chunk[<变量初始化>
                [self:cal : Natural 0] (code:comment "当前精灵携带的卡路里总数")
                [peak:cal : Natural 0] (code:comment "当前已知最高卡路里数")]

本段代码碎片里定义了两个变量： @:var{self:cal} 和 @:var{peak:cal}。
嗯，两个名字很奇怪的变量。@margin-note*{比如，
 @litchar{3x-b+C}, @litchar{D:/word.docx},
 @litchar{sin72º}, @litchar{《语文》}
 等等各种人类一看就懂的名字都没有问题。
}绝大多数程序语言都会喋喋不休地跟你强调“什么样的字符不能用来给变量命名”，
相当无语有没有？
用 Racket 你基本不用操心这个问题，
@focus{只要不与语法冲突就都是有效的名字}。
至于特殊符号在变量名中有无特别的含义？
没有，都是语言社区或代码作者自己的风格。
本例中，你可以将 @litchar{:cal} 理解为
@:var{self} 和 @:var{peak} 携带的单位名称;
或者 @:var{cal} 位于不同的名字空间里。
 
用空格与其他单词隔开的单独的冒号(@:delim{:})是语法结构，
它后面跟着的第一个单词(或用括号括起来的多个单词)是@tech{类型}信息。
本例中的两个变量均为@:term{自然数}类型(@:type{Natural})，
再之后的 @racket[0] 即是变量的初始值。

@:desc{读取一行}就是字面直译，@:desc{从卡路里清单 @var{calin} 里面读取一行}。

@handbook-chunk[<读取一行>
                (read-line calin 'any)]

函数 @racket[read-line] 的求值结果@handbook-footnote{Racket 不太强调“返回值”这个说法，
 而更偏好“求值结果”(evalutes to a result)。
 如果你已经习惯了其他语言的叫法，那就你按自己的习惯来。
 }要么是一个字符串（@:type{String}），
要么是一个特殊值 @tamer-defterm{EOF}(End of File）,表示@:term{文件结尾}。
因此@:desc{判断是否有内容}的意思是@:desc{读到的内容是否是一个字符串}，
空行对应空字符串。
也就是说，读到的行不包含行尾的换行符。

@handbook-chunk[<判断是否有内容>
                (string? line)]

当读到的是字符串时，就@:desc{尝试将它转化为数字}。
在静态强@tech{类型}语言里，这一步必须明确写出来。
也存在一些动态@tech{类型}语言或弱@tech{类型}语言，
它们会自动把看起来像数字的文字转化成数字，
但这种自动转化经常变成调试程序的灾难。

@handbook-chunk[<尝试提取卡路里信息>
                (string->number line)]

@margin-note{Racket 习惯在名字中使用箭头符号 @litchar{->} 来形象地表明“转化”这个动作。}
函数 @racket[string->number] 的求值结果@:desc{可能是一个数}（@:type{(Option Number)}）。
@emph{可能}的意思是这个字符串的内容也许压根就不是一个有效的数，
当转化失败时，我们习惯将求值结果设定为 @racket[#false]。
Racket 的数（@:type{Number}）就是指复数，
可以细分为有理数、整数、浮点数等。
但在本题中，卡路里肯定是正整数，其他都不对。

@handbook-chunk[<判断是否是正整数>
                (exact-positive-integer? cal)]

@margin-note{Racket 的谓词函数通常以 @:delim{?} 结尾。}
像 @racket[string?] 和 @racket[exact-positive-integer?] 这样
@:desc{接受一个任意@tech{类型}的参数，得到一个布尔型（@:type{Boolean}）的结果（@racket[#true]或@racket[#false]），
用以检查输入参数是否满足某些条件}的函数称为@handbook-deftech[#:origin "Predicate Function"]{谓词函数}。

@handbook-scenario{函数式编程}

在翻译那两段和@:term{更新}有关的碎片之前，我们先要对函数式编程有个初步的了解。
@handbook-deftech[#:origin "Functional Programming"]{函数式编程}通过定义函数来求解问题，
只是这里的函数是@focus{严格意义上的数学函数}。
相较于常规语言里的函数，数学函数的典型特征是，
有定义域和值域来约束输入参数和求值结果，
且@focus{变量的值一定不会被函数修改}。
按照这个说法，用常规语言的术语来说，
函数式编程中应该没有@:term{变量}只有@:term{常量}才对。
但其实，@focus{函数式编程中的变量也是数学中的变量}，
即代数、方程中出现的类似@${x}、@${y}、@${z}的符号。
在不同的前提条件下，它们可以取不同的值，是为“变”；
然而，一但条件确定，它们的值也就不再改变，
进而导致对函数的求值也不会改变。
而常规语言中的变量，它们只是给内存中的某个位置起了个名字，
它们的值取决于那块内存地址里存放的内容。
打个比方，数学变量相当于身份证上的姓名，
不同人的名字可以相同可以不同，
但每个人的名字在第一次确定之后（一般）不可更改，
点名时也（基本）可以确定你就是你；
程序语言变量相当于屋子的门牌号，
屋子里面有什么取决于什么样的人或物能进去。

如果你上过常规编程课，想必你肯定花了好一段时间才适应，
等号（@:delim{=}）在数学和在程序语言中的不同。
别气馁，我也经历过这样的瞎折腾。
不过，现在，我们需要重新回归数学思维。
@tech{函数式编程}的本质是@focus{代数变换}，
因而等号（@:delim{=}）就是关系运算符，
没有@:term{赋值}语义，
@margin-note*{除非你在用反证法推理}
也就不会出现诸如@${i = i + 1}这样令人困惑的语句。
那么，用数学语言如何表达上述迷惑用法呢？
答案是 @focus{@${i_{n+1} = i_n + 1}}，
这种递推写法在数列或数学归纳法中极为常见。

既然提到了数学归纳法，那就必然要提及另一个跟它关系密切的概念：@:term{递归函数}。
@margin-note*{俗称套娃}@handbook-deftech[#:origin "Recursive Function"]{递归函数}是一类特殊函数，
它们通过@focus{对自身求值来将复杂问题拆解成规模更小的同类子问题以各个击破}。
递归函数不是新鲜概念，现代常规语言里都有。
但除了开销太大外，常规语言的递归函数有个致命缺陷：
它们调用自身的次数不能太多，否则程序会奔溃。
因此，@:thus{常规语言往往优先使用循环来解决递归问题}。
函数式语言里的递归函数则没有那些缺陷，毕竟函数才是人家的灵魂。
反倒是普通循环不被函数式待见，因为普通循环必然要修改变量，
这严重违背了@focus{数学变量不可变}原则。
铺垫了这么多，我只是想说，
@focus{@tech{递归函数}和循环是一回事}。
@linebreak[]

回归主线任务，重新审视一下代码碎片@racket[<读取-判断-更新循环>]中的固定格式。
@:stx{let} 就是数学求解中常用的@:term{设}或@:term{令}，
如果顺便给 @:stx{let} 起个名字，
就会同时定义一个同名函数(本例中即为二元函数 @:sym{rpul})，
并用预设的自变量作为参数来调用它。

@:desc{更新当前精灵卡路里}实际做的事是@:desc{将读到的卡路里数累加到自己的卡路里总和里去}，
并保持最大卡路里不变。用数学语言说，即：@$${
 \mathit{self}_{n+1} & = \mathit{self}_n + \mathit{cal}_n \\
 \mathit{peak}_{n+1} & = \mathit{peak}_n
}

根据@tech{函数式编程}对递归函数和普通循环的偏好，
函数 @:sym{rpul} 会在@:desc{每一轮循环结束时再次对自己求值以启动下一轮循环}。
而循环的性质保证了，@:desc{本轮循环结束时的变量值即是下轮循环中变量的初始值}，即：
@${ \mathit{rpul}(\mathit{self}_{n+1}, \mathit{peak}_{n+1}) }

@handbook-chunk[<更新精灵卡路里，递推下一轮>
                (rpul (+ self:cal cal) peak:cal)]

同理，@:desc{更新最大卡路里}的数学原理是：@$${
 \mathit{self}_{n+1} & = 0 \\
 \mathit{peak}_{n+1} & = \max\{\mathit{self}_n, \mathit{peak}_n\}
}

@handbook-chunk[<更新最大卡路里，递推下一轮>
                (rpul 0 <确定最大值>)]

无论如何，变量 @:var{self:cal} 和 @:var{peak:cal} 的值至始至终都没有变过，
只不过它们在各自循环中的使命完成之后就不再现身，而被下一轮循环中的自己@:term{替换}掉了。
就好比，电影续作中的主角还在，也仍然叫那个名，但是主角演员被其他人@:term{替换}走了。

撇开数学原理不谈，本题简单到毫无悬念。
但是，你注意到，为什么@racket[<确定最大值>]要单独拿出来说吗？
它在函数 @:sym{rpul} 中出现了两次，
一次是碰到空行时，一次是碰到@tech{EOF}时。
例子里只强调了精灵与精灵之间用空行分隔，
那最后一只精灵后面有没有空行呢？
其实没有，因为每只精灵写清单时只负责与前面的精灵隔开，不负责后面的。
因此，文件没有更多内容时，最后一只精灵携带的卡路里还没有核算，
需要单独处理一下。

@handbook-chunk[<确定最大值>
                (max self:cal peak:cal)]

到这里，从解谜的角度来说，我们已经打好草稿了；
从答题的角度来说，还缺少一步：把草稿誊写到答题卡上。
@:stx{let} 定义的函数是一次性的，
你写完它还没来得及用就被扔进垃圾桶了，
这种匪夷所思的事几乎不会发生在真实世界中，
但确实就有可能发生在数字世界里。
因此需要把它放置在另一个正式函数里才能随叫随用。
这便是本节一开始就提到的两个主线任务碎片之一：

@handbook-chunk[<主线任务：求解谜题1>
                (define find-top-calorie <函数find-top-calorie的类型签名>
                  (λ <函数find-top-calorie的参数列表>
                    <读取-判断-更新循环>))]

@margin-note{λ 是希腊字母，在函数式语言里代表的正是函数本体。
 在 Racket 中也可写成英语的 @racket[lambda]。}
相对于草稿纸上的函数 @:sym{rpul}，
这个任务碎片用 @:stx{define} 和 @:stx{λ} 严肃定义了一个叫做 @:id{find-top-calorie} 的函数，
其除了在内部包含了@racket[<读取-判断-更新循环>]本体外，
还需标注清楚@tech{类型签名}和参数列表。

所谓@handbook-deftech[#:origin "Type Signature"]{类型签名}，
简单来说就是函数的定义域(输入参数)和值域(求值结果)应当满足的@tech{类型}约定。
标注@tech{类型签名}的方式有很多，
比较常见的是像下面这样：

@handbook-chunk[<函数find-top-calorie的类型签名>
                : (-> Input-Port Natural)]

跟标注变量@tech{类型}时一样，函数的@tech{类型}信息也跟在用空格隔开的单个冒号（@:delim{:}）后面。
@focus{@:delim{(-> )}表明这个@tech{类型}代表的是一个函数，
里面的最后一个@tech{类型}名表示函数的值域@tech{类型};
其余@tech{类型}名按顺序依次表示每一个输入参数的@tech{类型}。}
于是，函数 @:id{find-top-calorie} 的功能可以简单表述为：
@:thus{给定一个类型为@:term{输入流}（@:type{Input-Port}）的输入参数，
 得到一个类型为@:term{自然数}（@:type{Natural}）的结果。}
完美匹配了第一个谜题的要求：
@:desc{阅读精灵写的卡路里清单，计算得到携带食物最多的精灵总共能提供多少卡路里。}

@focus{类型签名只强调参数的类型，不强调参数的名字}。
因为计算机不懂名字的寓意，它们更擅长通过@tech{类型}来理解程序；
而人类读者更习惯通过“有意义的名字”来理解内容。
因此，我们把类型为 @:type{Input-Port} 的参数命名为 @:var{calin}（即
@litchar{cal}orie list @litchar{in}put-port 的缩写）：

@handbook-chunk[<函数find-top-calorie的参数列表>
                [calin]]

你注意到代码碎片@racket[<读取一行>]里也用到变量 @:var{calin} 了吗？
这也是 @:sym{rpul} 草稿函数实锤的一个重要原因：
它知道如何解谜，但是没有花精力去关注数据到底从哪来。
当它被放置在 @:id{find-top-calorie} 里时，
就自动共享了@:term{输入流} @:var{calin}。
读取数据就像打开水龙头就有水流出来一样自然。

@handbook-scenario{REPL}

函数 @:sym{rpul} 的命名借鉴了Lisp语系传统的
@handbook-deftech[#:origin "Read-Eval-Print Loop" #:abbr "REPL"]{读取-求值-打印循环}。
即，每一轮循环要做的事是：@:desc{读取用户输入的表达式，计算此表达式的结果，再把结果打印出来。}
这个循环看起来不太起眼，但在很多场合能极大的提高你的开发效率，
因为你不用单独准备一个完整的测试程序就可以立即检查函数的运行是否符合预期。
因而时至今日，好多语言都抄了一个类似的东西。
比如运行 @exec{idle.exe}，那就是 Python 的 @tech{REPL}，
只是它用了另一个更常见的名字，叫做@:term{Shell}。

在本书中，Racket 的 @tech{REPL} 既用于举例，也用于直接运行我们主线任务中的代码。
它看起来是这个样子的：

@tamer-repl[(code:comment "这是一个 Flonum 类型的值")
            3.14]

分号（@:delim{;}）及后面的黄色文字是程序注释，不是必须存在。
提示符（@:delim{>}）后面的就是用户输入的表达式，
如注释所言，本例演示的是 Racket 的@tech{值}。
Racket 读取到一个表达式之后，
会对该表达式求@tech{值}（尝试化简该表达式），
然后打印出@tech{值}的@tech{类型}信息(@:out{@:delim{- :}和后面的紫色文字})和内容（@:res{最后面的蓝色文字}）。

这段话看起来很绕口。
所谓@handbook-deftech[#:origin "value"]{值}，
指的就是不可再化简的表达式。
所以上面的 @racket[3.14] 的值就是它自己。
要不我们就索性再捋一捋，程序中几个最基础但又特容易弄混的概念，
以及@tech{函数式编程}中的函数的独特之处。开始：

@tamer-repl[(code:comment "给上面的值起个名字叫做π")
            (define π : Flonum 3.14)
            (code:comment "于是你可以用变量名π来代指3.14 (即：化简π得到最终值3.14)")
            π
            (code:comment "string? 也是一个变量名，会被替换成一个(-> Any Boolean)类型的值")
            string?
            (code:comment "λ是产生函数的表达式，下面这句会被替换成一个(-> Any Any)类型的值")
            (λ [arg] arg)
            (code:comment "给上面的函数值起个名字叫做id")
            (define id : (-> Any Any) (λ [arg] arg))
            (code:comment "于是你可以用变量名id来代指(λ [arg] arg)")
            id
            (code:comment "你也可以用变量名id将(λ [arg] arg)用作函数")
            (id π)]

迷糊了没？迷糊就对了。
简单来说，在函数式语言里，
函数既可以用来操作其他的@tech{值}，
它们自己也跟普通的@tech{值}一样，是一种特殊的@tech{值}。
在 Racket 中，这类特殊的@tech{值}统称为 @:id{procedure}(也即：
可执行的过程@handbook-footnote{实际上，程序语言中从来没有“函数”这个东西，
 有的都只是“过程”。但，既然不存在真正的函数，那就继续叫它们函数好了。})。
不给@tech{值}起名，它们就都是只存在于草稿纸上的一次性用品，
只有用 @:stx{define} (或其他定义变量的语法)给它们起名之后，
它们才算获得了正式身份。
注意看上面例子中的 @racket[id] 和 @racket[(λ [arg] arg)] 的@tech{值}的差别：
前者是 @procedure{id}，名字叫 @:id{id};
后者是 @:res{#<procedure>}, 没有名字，因而也被称为匿名函数。

于是，接下来我们实际运行一下主线任务中的函数来验证它是否正确：

@tamer-repl[#:requires ["../aoc.rkt"]
            ($ find-top-calorie #:< "mee/01_cc.aex" #:expect 24000)]

求值的最终结果是 @racket[24000]，符合预期。
@margin-note*{如果结果不对，本文也将不复存在。}
任务数据保存在后缀名为 @litchar{.aoc} 的文件中：

@tamer-repl[($ find-top-calorie #:< "mee/01_cc.aoc")]

第一个谜题求解完毕。提交这个答案，解锁第二个谜题。

@story*[
 @story{当你在冥思苦想求解第一个谜题时学到的爆炸性信息时，
  精灵们又开始搞事了：
  天，这么点零食迟早会被吃完的！
  这可不行，你必须再找到另外两个所带食物提供了最多卡路里的精灵。
  这样，一只精灵的零食吃完了，
  咱还有俩可以继续腐败。}
  
 @story{请帮助精灵们@question{找出携带食物所提供卡路里最多的前三只精灵，
   并计算他们所带食物所能提供的卡路里总和。}}]

根据题意可知，例子中携带食物提供卡路里最多的三只精灵分别是第四只（@racket[24000] 卡）、
第三只（@racket[11000] 卡）和第五只（@racket[10000] 卡），总计 @racket[45000] 大卡。

精灵们的这两次提问都比较拗口，但是不难看出，
用第二个谜题的思路来说，第一个谜题其实就是
@:desc{携带食物所提供的卡路里最多的前一只精灵所能提供的卡路里总和}。
换句话说，这两个谜题其实是一个问题，差别只在于数量的多少。
于是，自然而然地，@focus{不同数量相同类型数据可以构成数组、列表、元组等复合类型}。
在不同的语言里，这些数据类型都可以是很趁手的选择。

@handbook-scenario{S-expressions}

现在，我想先讲点特别的。
你已经注意到了，Racket 代码写起来很奇怪，括号套着括号。
是的，它确实奇怪，这也是它不流行的原因之一，
但这种写法与数学的渊源却颇为深刻。

高级程序语言起源于上世纪50年代，
但那些无外乎是对机器语言的直白翻译（用英文单词来替代@racket[0]@racket[1]串），
语法也是互相借鉴。
总之，没有特别亮眼的创新，
特别是缺乏数学的美感。

Racket 是 Lisp 语系的一种方言，
也可以一直追溯到50年代，人工智能研究领域。
不过，至于 Lisp 到底是怎么来的，恐怕已经永远消失在历史的迷雾中了。
现在公认的看法是麻省理工学院的 John McCarthy 于1959年立项，
直接基于数学而发明的全新的程序语言。
动机很简单，影响却极为深远。
@idea{程序编制者应该关注问题本身，而不是被迫淹没在琐碎的机器细节里，
 而从人类思维到机器思维之间的脏活，该由程序语言来搞定}。
在 Lisp 的所有方言里，Racket 这一支最为看重数学理论的优雅和纯粹
@handbook-footnote{2010年代起 Racket 开始弥补在实用性方面的不足}。
总之，现今存在的绝大多数语言，它们宣传中那些出神入化的所谓“新”东西，
都是Lisp玩剩下了才被那些语言的作者发现而抄过去的。

Lisp 全称@:term{表处理语言}（LISt Processing），
言下之意，列表是其基础数据@tech{类型}，
用它@focus{求解问题的思路也就转化成了对列表的操作}。
@handbook-deftech[#:origin "List"]{列表}是一种容器，
里面@focus{按顺序}存放着很多@tech{值}，可以相同也可以不同。
列表中的元素通过@:term{自然数}@:term{下标}来访问，
下标从 @racket[0] 开始计数；
列表中所含数据的个数称为@:term{列表的长度}。

列表在不同语言、不同场景表示的并非相同的东西，有时甚至会影响你的思路。
比如，Python 的列表（@:id{list}）是@:term{顺序表}；
C++ 的列表（@:id{std::list}）是@:term{链表}。
它俩涵盖了绝大多数情况。
而专业处理列表的 Lisp/Racket，
其列表（@:id{list}）是@:term{广义表}。

Lisp/Racket 特殊在，它们连语法都写成了广义表的形式。
任意一类括号（@:delim{() [] @|"{}"|}）都能用来界定广义表，
广义表里的元素可以是常规数据，也可以是另一个广义表，甚至是自己套自己。
这种写法称作@handbook-deftech[#:origin "Symbolic Expression" #:abbr "sexp"]{符号表达式}，
是@focus{函数式递归在文法上的实现}。

文法设计方面的话题我不在这展开，直接说重点。
我们从幼儿园就开始学习的算术表达式，
其写法属于中缀记法，总是把操作符写在操作数的中间；
而 @tech{sexp} 是一种前缀记法，
@focus{总是把操作符写在操作数的前面}。
前缀记法的优点很多，比如无需考虑运算符优先级；
方便计算机处理。
最关键的是，
它@focus{确实更契合数学运算的语义}。

实际上，数学学得越深，数学表达式的写法就越五花八门。
比如一元二次方程求根公式和三角恒等式@$${
 \frac{-b \pm \sqrt{b^2 - 4ac}}{2a} \\
 \sin^2\theta + \cos^2\theta = 1
}就已经混进去了不少奇怪的东西，肯定不能都算中缀记法。

初等数学中的二元运算符往往也能推广到多元场景。
以加法为例，@:desc{计算十个数的和}，与@:desc{计算两个数的和}，
在计算法则上没有任何区别。
但用中缀记法，需要写十个数、九个加号：
@$${ a + b + c + d + e + f + g + h + i + j }
而写成 @tech{sexp}，只需要十个数、一个加号（以及一对括号充当边界）：
@centered{@racket[(+ a b c d e f g h i j)]}
还有一些二元运算，没有约定俗成的记号，就只能写成函数形式。
比如求最大公约数的@${ \gcd(a, b) }，
这不就很像前缀记法了吗？括号不能省，还得增加逗号来分隔参数。
@:thus{@tech{sexp} 统一了以上（和其他）所有奇奇怪怪的写法：
 广义表的第一个元素代表操作符（函数），
 其余所有元素都是该操作符（函数）的操作数（参数）}，漂亮。
@linebreak[]

既然花了大量时间来说@tech{列表}，
那求解第二个谜题的工具就是它了，
以后我们也会经常用它解决别的问题。
此外，在定义函数的时候，
也应当在原题的基础之上适当考虑通用性。
万一又有精灵来整活呢？
@:desc{找一个}也好，@:desc{找三个}也罢，都只是@:desc{找n个}的特定案例。
因此，相较于求解第一个谜题的 @:id{find-top-calorie} 函数，
这个复数形式的 @:id{find-top-calories} 函数增加了一个类型为 @:type{Natural} 的参数 @:var{n}：

@handbook-chunk[<主线任务：求解谜题2>
                (define find-top-calories : (-> Input-Port Natural Natural)
                  (λ [calin n]
                    (let rpul ([self:cal : Natural 0]
                               <初始化高卡路里列表>)
                      (define line : (U String EOF) (read-line calin 'any))
                      (if (string? line)
                          (let ([cal : (Option Number) (string->number line 10)])
                            (if (exact-positive-integer? cal)
                                (rpul (+ self:cal cal) calories)
                                (rpul 0 <更新高卡路里列表>)))
                          <高卡路里合计>))))]

从上面这段碎片里，
我们也可以大致看出求解第一个谜题时被拆得稀碎的代码组装成最终程序后的样子。

算法逻辑大同小异，区别在于新的 @:sym{rpul}
函数里代表最大值的参数类型从 @:type{Natural} 变为了 @:type{(Listof Natural)}：

@handbook-chunk[<初始化高卡路里列表>
                [calories : (Listof Natural) (make-list n 0)]]

最终结果变为了@:desc{最大值列表的和}。

@handbook-scenario{高阶函数}

前面在比较 @tech{sexp} 和算术表达式的中缀记法时提到了多操作数加法的写法，这就来了个具体例子。
数的列表即是@:term{数列}，数学里有个专门的符号来表达@:desc{数列前n项的和}：
@$${ \sum_{i=1}^n a_i }
是不是感觉大脑突然宕机了？
不用管它，用 @tech{sexp} 写要简洁得多：

@handbook-chunk[<高卡路里合计>
                (apply + <更新高卡路里列表>)]

加法操作符（@:id{+}）前面多了一个 @:id{apply} 函数，
后面的参数从多个数变成了一个列表。
函数 @:id{apply} 的功能是将列表里的数按顺序取出，
再作为操作数全部喂给操作符 @:id{+}。
这个表达式的结果就是对列表中的所有数@:desc{执行加法运算}的结果。
这时候用 @tech{REPL} 来演示更好：

@tamer-repl[(+ 1 2 3 4 5 6)
            (apply + (list 1 2 3 4 5 6))]

还没结束，这段代码碎片引出了@tech{函数式编程}中的另一个重要概念：@:term{高阶函数}。
@handbook-deftech[#:origin "Higher-Order Function"]{高阶函数}的输入参数中至少有一个必须是其他函数，
或者求值结果是一个函数。
它们是@tech{函数式编程}中实现代码复用的强力工具，
也是初学者理解@tech{函数式编程}的一道砍。
@linebreak[]

最后是针对列表设计的更新最大值逻辑：
@:desc{将当前精灵所携带的卡路里插入到列表中更小的元素之前，并踢掉列表尾部的元素}。

不太好理解的样子。
给自己一点耐心，不妨先拿出纸和笔来模拟一下这个过程。
一开始，列表里全是 @racket[0]，
无论哪只精灵的卡路里清点好了，
他都是第一名，会占据列表的第一个位置。
以后每有一只精灵准备好了，
他都要跟那只精灵比，
比输了就让出第一名，往后挤走最后一名。
如果第一名很幸运没输，
那同样的戏码会在列表的第二个位置处上演。
依此类推。

以上模拟是为了理解问题，
真正的解决之道还在于@focus{将该问题转化为对列表的操作}。
@:desc{将自己挤进列表}实际上在做的事是
@:desc{将列表拆分成两个小列表，
 一个里面的元素都比自己大(或相等)，
 另一个里面的元素都比自己小，
 然后把这三部分按大小顺序连接成一条新列表，
 并只保留前 n 个元素}。

是不是感觉这两种思维方式的画风变化有点大？
@:term{查找}、@:term{插入}、@:term{更新}和@:term{删除}
是作用于各种数据结构最常见的操作，列表则是其中最简单的代表。
因此提供列表的语言也会同时为我们提供一大堆列表操作函数，
我们只需要弄清楚@:desc{对列表做什么}而
不用浪费时间去想@:desc{具体怎么做}（不同列表的做法还真不一样）。
这就是思维方式的提升@handbook-footnote{如果你用C语言做任务，
 那就真的要自己去写循环模拟上面我们理解问题的那个过程。}。

@margin-note*{虽然 Racket 提供了不少直接用于拆分列表的函数，
 但是今天已经接触太多让人炸裂的知识了，
 到最后这个环节就不折腾了，一切从简。}
从拆分的结果来说，
相当于对列表做了两轮筛选（对应着上述数据结构基本操作中的@:term{查找}）：
@:desc{第一轮筛选出列表中所有比当前精灵卡路里大(或相等)的元素；
 第二轮筛选出列表中所有比当前精灵卡路里小的元素。}
再执行一系列基本操作（连接列表用 @racket[append]、
截取列表用 @racket[take]，不再此详述），
由此得到的新列表即为下一轮循环的初始值。

于是，@handbook-chunk[<更新高卡路里列表>
                   (let ([tops (filter <高卡路里过滤函数> calories)]
                         [tail (filter-not <高卡路里过滤函数> calories)])
                     (take (append tops (list self:cal) tail) n))]

这段看似平平无奇的代码碎片引出了一个典型的高级列表操作：@racket[filter]。
不过，鉴于 @racket[filter] 函数的@tech{类型签名}对初学者来说太过犯规，
这里就不放出来了，我针对本题给个简单版本：
@margin-note*{注意，这段代码碎片没有包含在任何其他碎片中，因此不会出现在最终代码里。}

@handbook-chunk[<filter简易类型签名>
                (-> (-> Any Boolean) (code:comment "参数1类型：过滤函数")
                    (Listof Natural) (code:comment "参数2类型：自然数列表")
                    (Listof Natural))]

跟着注释不难看出，
@racket[filter] 函数接受一个过滤用的@tech{谓词函数}和一个自然数列表，
得到另一个自然数列表，而该列表中的元素均为原列表中能够满足过滤函数的元素。
同理，@racket[filter-not] 函数与 @racket[filter] 函数的@tech{类型签名}相同，
但像它的名字一样，得到的结果列表中的元素均不能满足过滤函数。
理清这一点后，过滤高卡路里的@tech{谓词函数}就不难理解了：

@handbook-chunk[<高卡路里过滤函数>
                (λ [[peak:cal : Natural]]
                  (peak:cal . >= . self:cal))]

显然，这个@racket[<高卡路里过滤函数>]只会被用一次，
因此不必非得给它起名字。
好吧，这里用了两次，
但两次产生的函数本体虽然一摸一样，
它们也仍然是不同的@tech{值}。
可理解为同卵双胞胎。

匿名函数和@tech{高阶函数}是绝配，
经后我们还会学习其他更数学的产生匿名函数的方法。

至此，今天的任务终于完成了：

@tamer-repl[($ find-top-calories 3 #:< "mee/01_cc.aex" #:expect 45000)
            ($ find-top-calories 3 #:< "mee/01_cc.aoc")]

提交这个答案，解锁明天的任务。

此外，我们还可以对比一下这两个谜题在逻辑上的一致：

@tamer-repl[($ find-top-calorie    #:< "mee/01_cc.aoc")
            ($ find-top-calories 1 #:< "mee/01_cc.aoc")]

文中出现了好几处理论性较强的段落，
你现在看不懂才是正常现象，
有待我们在后续任务中慢慢体会。
最重要的是，
@idea{我在帮你种@tech{函数式编程}的种子，
 相信他日定会发芽}。

@;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@handbook-reference[]
